

#pragma once

#include <Eigen/Eigen>
#include <vector>

CPPGL_NAMESPACE_BEGIN

// ---------------------------------------------------------------------------
// Code adapted from:
// https://github.com/darglein/saiga
//    MIT License
//
//    Copyright (c) 2021 Darius RÃ¼ckert <darius.rueckert@fau.de>
//
//    Permission is hereby granted, free of charge, to any person obtaining a copy
//            of this software and associated documentation files (the "Software"), to deal
//    in the Software without restriction, including without limitation the rights
//            to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//            copies of the Software, and to permit persons to whom the Software is
//    furnished to do so, subject to the following conditions:
//
//    The above copyright notice and this permission notice shall be included in all
//            copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//            AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//    SOFTWARE.
// ---------------------------------------------------------------------------

/**
 * Simple Random numbers that are created by c++11 random engines.
 * These function use static thread local generators.
 * -> They are created on the first use
 * -> Can be used in multi threaded programs
 */
    namespace random {
        /**
         * Sets a random seed.
         * By default the seed is generated by the time.
         * Take care, that the random generator is thread local.
         * Therefore every thread has to call this method.
         */
        void setSeed(uint64_t seed);

        /**
         * 1. Generates a seed using std::chrono::system_clock::now().
         * 2. Computes a few iterations on std::mt19937 so that the output is not close
         * anymore.
         */
        uint64_t generateTimeBasedSeed();

        /**
         * Returns true with a probability of 's'.
         * s must be in the range [0,1].
         */
        bool sampleBool(double s);

        /**
         * Returns a uniform random value in the given range.
         */
        double sampleDouble(double min, double max);

        /**
         * Returns a uniform random value in the given range.
         */
        float sampleFloat(float min, float max);

        /**
         * Uniform integer in this range.
         * Note:
         * The high-bound is inclusive!!!
         */
        int uniformInt(int low, int high);

        /**
         * A normal-distributed random value
         */
        double gaussRand(double mean = 0, double stddev = 1);

        /**
         * Similar to std::rand but with thread save c++11 generators
         */
        int rand();

        /**
         * Similar to std::rand but with thread save c++11 generators
         */
        uint64_t urand64();

        /**
         * Returns 'sampleCount' unique integers between 0 and indexSize-1
         * The returned indices are NOT sorted!
         */
        std::vector<int> uniqueIndices(int sampleCount, int indexSize);

        Vec3 ballRand(double radius);

        Vec3 sphericalRand(double radius);

        template<typename MatrixType>
        MatrixType MatrixUniform(typename MatrixType::Scalar low = -1,
                                 typename MatrixType::Scalar high = 1) {
            MatrixType M;
            for (int i = 0; i < M.rows(); ++i)
                for (int j = 0; j < M.cols(); ++j)
                    M(i, j) = sampleDouble(low, high);
            return M;
        }

        template<typename MatrixType>
        MatrixType MatrixGauss(typename MatrixType::Scalar mean = 0,
                               typename MatrixType::Scalar stddev = 1) {
            MatrixType M;
            for (int i = 0; i < M.rows(); ++i)
                for (int j = 0; j < M.cols(); ++j)
                    M(i, j) = gaussRand(mean, stddev);
            return M;
        }

        template<typename Scalar>
        Eigen::Quaternion<Scalar> randomQuat() {
            using Vec = Vector<Scalar, 4>;
            Vec r = random::MatrixUniform<Vec>(-1, 1);
            Eigen::Quaternion<Scalar> q;
            q.coeffs() = r;
            q.normalize();
            if (q.w() < 0)
                q.coeffs() *= -1;
            return q;
        }

    } // namespace random

    inline double linearRand(double low, double high) {
        return double(cppgl::random::sampleDouble(low, high));
    }

    template<typename Derived>
    inline typename Derived::PlainObject linearRand(
            const Eigen::DenseBase<Derived> &low,
            const Eigen::DenseBase<Derived> &high) {
        typename Derived::PlainObject result;
        for (int i = 0; i < low.rows(); ++i) {
            for (int j = 0; j < low.cols(); ++j) {
                result(i, j) = linearRand(low(i, j), high(i, j));
            }
        }
        return result;
    }

    extern vec2 diskRand(float Radius);

// ---------------------------------------------------------------------------
// End of adapted code
// ---------------------------------------------------------------------------
CPPGL_NAMESPACE_END